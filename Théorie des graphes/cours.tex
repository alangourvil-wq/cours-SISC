\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\title{Théorie des graphes}
\date{}
\renewcommand{\contentsname}{Sommaire}
\usepackage{setspace}
\onehalfspacing
\setlength{\parindent}{0pt}

\begin{document}

\maketitle

\section*{Qu'est-ce qu'un graphe ?}

Un graphe est une structure mathématique composée de :
\begin{itemize}
    \item Un ensemble de \textbf{sommets} (ou nœuds, ou points)
    \item Un ensemble d'\textbf{arêtes} (ou arcs, ou liens) reliant ces sommets
\end{itemize}

\textbf{Définition formelle} : Un graphe \( G \) est défini par un couple \( (S, A) \) où \( S \) est un ensemble fini de sommets et \( A \) un ensemble de paires de sommets (arêtes). Chaque arête est une paire \( (u, v) \) où \( u \) et \( v \) sont des sommets de \( S \).

\textbf{Remarque} : Il peut y avoir zéro ou une arête entre chaque paire de sommets. Les arêtes peuvent être orientées ou non, et peuvent être pondérées (associées à un poids, par exemple une distance ou un coût).

% Image du graphe de base (à insérer ici)
\includegraphics[width=0.3\textwidth]{Image graphe de base.png}
% [Ajouter en commentaire : Il faut ajouter ici l'image du graphe de base avec sommets et arêtes.]

\section*{Comment dessiner un graphe}

Un graphe peut être dessiné de multiples façons sans changer sa structure. Par exemple, pour les sommets \( A, B, C, D \) et les arêtes \( AD, BD, BC, CD \), on obtient toujours le même graphe, quelle que soit la disposition des sommets dans le plan.

% Images des différentes représentations du même graphe (à insérer ici)
\includegraphics[width=0.5\textwidth]{image du meme graphe.png}
% \includegraphics[width=0.3\textwidth]{image3.png}
% \includegraphics[width=0.3\textwidth]{image4.png}
% [Ajouter en commentaire : Il faut ajouter ici les images des différentes représentations du même graphe.]

\section*{À quoi sert un graphe ?}

Les graphes permettent de modéliser des relations entre des éléments dans de nombreux domaines :
\begin{itemize}
    \item \textbf{Réseaux sociaux} : Les sommets représentent des personnes, les arêtes des relations d'amitié.
    \item \textbf{Réseaux informatiques} : Les sommets sont des ordinateurs ou des routeurs, les arêtes des connexions.
    \item \textbf{Réseaux de transport} : Les sommets sont des villes ou des intersections, les arêtes des routes ou des voies.
    \item \textbf{Distribution d'énergie} : Les sommets sont des centrales ou des foyers, les arêtes des câbles ou des canalisations.
\end{itemize}

\section*{Les types de graphe}

\subsection*{Graphe complet}
Tous les sommets sont reliés entre eux par une arête. Il y a donc une arête entre chaque paire de sommets.

\subsection*{Graphe non connexe}
Un graphe est non connexe s'il existe au moins deux sommets qui ne sont pas reliés par un chemin.

\subsection*{Graphe vide}
Un graphe vide ne contient aucune arête, ce qui signifie qu'il n'y a aucune relation entre les sommets.

\section*{Notions de voisinage et degré}

Le \textbf{degré} d'un sommet est le nombre d'arêtes qui lui sont incidentes. Deux sommets sont \textbf{voisins} s'ils sont reliés par une arête.

\section*{Notion de chemin}

Un \textbf{chemin} est une suite de sommets reliés par des arêtes. La \textbf{longueur} d'un chemin est le nombre d'arêtes qu'il contient.

\section*{Notion de cycle}

Un \textbf{cycle} est un chemin dont les deux extrémités sont reliées, formant ainsi une boucle.

\section*{Notion de connectivité}

Un graphe est \textbf{connexe} si, pour toute paire de sommets \( U \) et \( V \), il existe un chemin entre \( U \) et \( V \).

\section*{Notion d'orientation}

Un graphe est \textbf{orienté} si ses arêtes ont un sens (on parle alors d'arcs). Dans un graphe \textbf{non orienté}, les arêtes n'ont pas de sens.

\section*{Notion de pondération}

Les arêtes peuvent être caractérisées par des \textbf{poids}, qui représentent par exemple :
\begin{itemize}
    \item Une distance (kilomètres entre deux villes)
    \item Un pourcentage (niveau d'affinité entre deux personnes)
    \item Un coût (prix du transport entre deux destinations)
\end{itemize}

\section*{Les arbres}

\subsection*{Définition d'un arbre}

Un \textbf{arbre} est un graphe \textbf{connexe} et \textbf{sans cycle}. Il existe plusieurs définitions équivalentes :
\begin{itemize}
    \item Un arbre est un graphe connexe et sans cycle.
    \item Un arbre est un graphe connexe avec \( n \) sommets et \( n-1 \) arêtes.
    \item Un arbre est un graphe sans cycle avec \( n \) sommets et \( n-1 \) arêtes.
\end{itemize}

% Image d'un arbre et d'un graphe qui n'est pas un arbre (à insérer ici)
\includegraphics[width=0.5\textwidth]{exemple arbre.png}
% [Ajouter en commentaire : Il faut ajouter ici une image d'un arbre et d'un graphe qui n'est pas un arbre.]

\subsection*{Types d'arbres}

Il existe plusieurs types d'arbres, selon leur structure :
\begin{itemize}
    \item Arbre binaire
    \item Arbre en étoile
    \item Arbre chemin
\end{itemize}
\includegraphics[width=0.5\textwidth]{differents types d arbres.png}

\section*{Arbres couvrants}

Un \textbf{arbre couvrant} d'un graphe connexe est un arbre qui passe par tous les sommets du graphe. Il est utilisé en informatique pour éviter les boucles dans les réseaux.

\subsection*{Algorithme de Kruskal}

L'algorithme de Kruskal permet de trouver un arbre couvrant de poids minimal dans un graphe pondéré. Il fonctionne en triant les arêtes par poids croissants et en ajoutant celles qui ne forment pas de cycle.

% Tableau de l'algorithme de Kruskal (à insérer ici)
\includegraphics[width=0.5\textwidth]{algorithme kruskal.png}
% [Ajouter en commentaire : Il faut ajouter ici un tableau ou un schéma expliquant l'algorithme de Kruskal.]

\section*{Parcours eulérien d'un graphe}

Un \textbf{parcours eulérien} est un chemin qui passe par toutes les arêtes d'un graphe une et une seule fois. Un graphe connexe admet un parcours eulérien si et seulement si tous ses sommets sont de degré pair, sauf éventuellement deux.

\section*{Plus court chemin entre deux sommets}

\subsection*{Algorithme de Dijkstra}

L'algorithme de Dijkstra permet de trouver le plus court chemin entre deux sommets dans un graphe pondéré. Il est largement utilisé dans les systèmes de navigation (GPS) et les réseaux informatiques.

% Schéma de l'algorithme de Dijkstra (à insérer ici)
\includegraphics[width=0.5\textwidth]{algorithme dijkstra.png}
% [Ajouter en commentaire : Il faut ajouter ici un schéma ou un exemple de l'algorithme de Dijkstra.]

\section*{Introduction à l'ordonnancement}
L'ordonnancement de tâches est une méthode essentielle en gestion de projet pour organiser et optimiser l'exécution des tâches dans un projet. L'objectif principal est de minimiser la durée totale du projet tout en respectant les contraintes de dépendance entre les tâches.

\subsection*{Objectifs}
\begin{itemize}
    \item Compresser au maximum le temps du planning.
    \item Identifier les tâches non compressibles.
    \item Identifier les tâches pouvant être parallélisées.
    \item Identifier les marges "au plus tôt" et "au plus tard" pour calculer le battement possible entre les tâches.
\end{itemize}

% Ajout d'une explication sur les méthodes d'ordonnancement
\subsection*{Explication des méthodes d'ordonnancement}
L'ordonnancement de tâches repose sur des méthodes comme la \textbf{méthode PERT (Program Evaluation and Review Technique)} et la \textbf{méthode du chemin critique (CPM - Critical Path Method)}. Ces méthodes permettent de modéliser les tâches et leurs dépendances sous forme de graphe, où chaque tâche est représentée par un nœud et les dépendances par des arcs. Pour plus de détails sur ces méthodes, voir \href{https://fr.wikipedia.org/wiki/Méthode_PERT}{Wikipédia - Méthode PERT}.

\section*{Définir un planning de tâche}

\subsection*{Représentation graphique des tâches}
Les tâches sont représentées par des sommets pondérés par leurs durées, et les arêtes correspondent aux dépendances entre les tâches. Voici un exemple de planning de tâches :

\includegraphics[width=0.5\textwidth]{exemple taches.png}
%\captionof{figure}{Exemple de planning de tâches avec durées et dépendances.}

% Ajout d'une explication sur les niveaux des tâches
\subsection*{Niveaux des tâches}
Les niveaux des tâches sont déterminés en fonction des dépendances. Une tâche de niveau 0 n'a pas de dépendance (pas d'arc entrant). Une tâche de niveau 1 dépend uniquement de tâches de niveau 0, et ainsi de suite.

% Ajout d'une explication sur les dates "au plus tôt"
\subsection*{Dates "au plus tôt"}
Les dates "au plus tôt" indiquent le moment le plus précoce auquel une tâche peut commencer, en tenant compte des dépendances. Elles sont calculées en partant du début du projet et en ajoutant les durées des tâches précédentes.

% Ajout d'une explication sur les dates "au plus tard"
\subsection*{Dates "au plus tard"}
Les dates "au plus tard" indiquent le moment le plus tardif auquel une tâche peut commencer sans retarder la fin du projet. Elles sont calculées en partant de la fin du projet et en soustrayant les durées des tâches suivantes.

% Ajout d'une explication sur les marges et battements
\subsection*{Marges et battements}
La marge d'une tâche est la différence entre sa date "au plus tard" et sa date "au plus tôt". Un battement de 0 signifie que la tâche est critique et ne peut pas être retardée sans affecter la durée totale du projet.

% Ajout d'une explication sur le chemin critique
\subsection*{Chemin critique}
Le chemin critique est la séquence de tâches critiques (avec un battement de 0) qui détermine la durée minimale du projet. Identifier le chemin critique permet de concentrer les efforts sur les tâches qui impactent directement la durée totale du projet.

\subsection*{Diagramme PERT}
Le meilleur moyen de faire un exercice d'ordonnancement de tâches est de réaliser le diagramme PERT.

\includegraphics[width=1\textwidth]{diagramme pert.png}

Voici un exemple de ce diagramme. Il contient un sommet de début et un sommet de fin. Les arêtes sont pondérées par la durée des tâches et contiennent le nom des tâches, et les sommets doivent référencer la date au plus tôt et la date au plus tard. Il est ainsi immédiat de trouver le chemin critique et les temps de battements.

\section*{Graphes - Notions de base des flots}

\subsection*{Définition et vocabulaire}

Un \textbf{réseau} est un graphe orienté où chaque arc est associé à une \textbf{capacité}, représentant la quantité maximale de flot qui peut circuler sur cet arc. Un réseau est généralement défini par :
\begin{itemize}
    \item Un ensemble de \textbf{sommets} (ou nœuds).
    \item Un ensemble d'\textbf{arcs} orientés reliant ces sommets.
    \item Une \textbf{source} \( s \) (sommet sans arcs entrants).
    \item Un \textbf{puits} \( t \) (sommet sans arcs sortants).
\end{itemize}

% Ajout : Définition formelle d'un réseau
\textbf{Ajout :} Un réseau est formellement défini comme un quadruplet \( (G, s, t, c) \), où \( G \) est un graphe orienté, \( s \) est la source, \( t \) est le puits, et \( c \) est une fonction de capacité associant à chaque arc une valeur réelle positive. \textit{Source : [Cormen et al., "Introduction to Algorithms", 3rd Edition, MIT Press, 2009, p. 726].}

% Image : Schéma d'un réseau simple avec source et puits
% TODO : Ajouter une image montrant un réseau avec source, puits et arcs orientés.

\subsection*{Un graphe orienté}

Un graphe orienté est un ensemble de sommets reliés par des arcs ayant une direction. Dans le contexte des flots, chaque arc a une \textbf{capacité} qui limite la quantité de flot pouvant y circuler.

\includegraphics[width=0.5\textwidth]{reseau.png}
% TODO : Ajouter une image montrant un graphe orienté avec des capacités sur les arcs.

\subsection*{Hypothèses pour simplifier}

Pour simplifier l'analyse des réseaux de flots, on suppose souvent que :
\begin{itemize}
    \item La source \( s \) n'a pas d'arcs entrants.
    \item Le puits \( t \) n'a pas d'arcs sortants.
\end{itemize}

\subsection*{Un flot}

Un \textbf{flot} est une fonction \( f \) qui associe à chaque arc \( (u, v) \) une valeur réelle \( f(u, v) \) représentant la quantité de flot circulant de \( u \) vers \( v \). Un flot doit respecter deux contraintes fondamentales :
\begin{enumerate}
    \item \textbf{Contrainte de capacité} : \( f(u, v) \leq c(u, v) \) pour tout arc \( (u, v) \).
    \item \textbf{Contrainte de conservation} : Pour tout sommet \( u \) différent de \( s \) et \( t \), la somme des flots entrants est égale à la somme des flots sortants.
\end{enumerate}

% Ajout : Explication de la contrainte de conservation
\textbf{Ajout :} La contrainte de conservation signifie que le flot est "conservé" à travers chaque sommet intermédiaire, c'est-à-dire qu'il ne peut y avoir ni accumulation ni perte de flot dans ces sommets. \textit{Source : [Ahuja et al., "Network Flows: Theory, Algorithms, and Applications", Prentice Hall, 1993, p. 15].}

\includegraphics[width=0.5\textwidth]{reseau 2.png}
% TODO : Ajouter une image montrant un flot valide avec les contraintes de capacité et de conservation.

\subsection*{La valeur d'un flot}

La \textbf{valeur d'un flot} est définie comme la quantité totale de flot sortant de la source \( s \) (ou entrant dans le puits \( t \)). Mathématiquement, la valeur \( |f| \) d'un flot \( f \) est donnée par :
\[ |f| = \sum_{v \in V} f(s, v) \]


\subsection*{Maximiser la valeur d'un flot}

L'objectif principal dans les réseaux de flots est de trouver un \textbf{flot maximal}, c'est-à-dire un flot dont la valeur est la plus grande possible. Cet objectif est atteint en utilisant des algorithmes comme celui de \textbf{Ford-Fulkerson} ou \textbf{Edmonds-Karp}.

% Ajout : Algorithme de Ford-Fulkerson
\textbf{Ajout :} L'algorithme de Ford-Fulkerson fonctionne en trouvant des \textbf{chaînes améliorantes} dans le graphe résiduel. Une chaîne améliorante est un chemin de la source au puits dans le graphe résiduel, où chaque arc a une capacité résiduelle positive. \textit{Source : [Cormen et al., "Introduction to Algorithms", 3rd Edition, MIT Press, 2009, p. 728].}

\includegraphics[width=0.8\textwidth]{graphe residuel.png}
% TODO : Ajouter une image montrant un graphe résiduel et une chaîne améliorante.

\subsection*{Savoir si on a un flot maximal}

Un flot est maximal si et seulement s'il n'existe plus de chaîne améliorante dans le graphe résiduel. Une autre façon de vérifier la maximalité d'un flot est de calculer la \textbf{capacité d'une st-coupe minimale}. Selon le \textbf{théorème max-flot min-coupe}, la valeur d'un flot maximal est égale à la capacité d'une st-coupe minimale.

% Ajout : Théorème max-flot min-coupe
\textbf{Ajout :} Le théorème max-flot min-coupe stipule que dans un réseau de flot, la valeur maximale d'un flot de \( s \) à \( t \) est égale à la capacité minimale d'une coupe séparant \( s \) de \( t \). \textit{Source : [Ford et Fulkerson, "Maximal Flow Through a Network", Canadian Journal of Mathematics, 1956].}

\includegraphics[width=0.8\textwidth]{st coupe.png}
% TODO : Ajouter une image montrant une st-coupe minimale dans un réseau.

\subsection*{Algorithme de Ford-Fulkerson}

L'algorithme de Ford-Fulkerson est utilisé pour calculer un flot maximal dans un réseau. Voici les étapes principales :
\begin{enumerate}
    \item Initialiser le flot à zéro pour tous les arcs.
    \item Trouver une chaîne améliorante dans le graphe résiduel.
    \item Augmenter le flot le long de cette chaîne par la capacité résiduelle minimale sur la chaîne.
    \item Mettre à jour le graphe résiduel.
    \item Répéter jusqu'à ce qu'il n'y ait plus de chaîne améliorante.
\end{enumerate}

% Ajout : Complexité de l'algorithme
\textbf{Ajout :} La complexité de l'algorithme de Ford-Fulkerson dépend de la méthode utilisée pour trouver les chaînes améliorantes. Avec une recherche en largeur (algorithme d'Edmonds-Karp), la complexité est \( O(VE^2) \), où \( V \) est le nombre de sommets et \( E \) le nombre d'arcs. \textit{Source : [Cormen et al., "Introduction to Algorithms", 3rd Edition, MIT Press, 2009, p. 734].}

\subsection*{Choix des chaînes améliorantes}

Le choix des chaînes améliorantes peut influencer l'efficacité de l'algorithme. L'algorithme d'\textbf{Edmonds-Karp} utilise toujours le plus court chemin (en nombre d'arcs) dans le graphe résiduel, ce qui garantit une complexité polynomiale.

% Image : Exemple de choix de chaînes améliorantes
% TODO : Ajouter une image montrant le processus de choix des chaînes améliorantes.

\subsection*{Affectation de tâches}

L'affectation de tâches est une application classique des réseaux de flots. Elle peut être modélisée comme un problème de flot maximal dans un graphe biparti, où les sommets représentent soit des tâches, soit des ressources.

% Ajout : Application à l'affectation de tâches
\textbf{Ajout :} Dans un graphe biparti, les tâches sont reliées à une source et les ressources à un puits. Les capacités des arcs représentent les contraintes d'affectation. \textit{Source : [Ahuja et al., "Network Flows: Theory, Algorithms, and Applications", Prentice Hall, 1993, p. 412].}



\end{document}
